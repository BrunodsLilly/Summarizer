package templates

templ Index() {
	@Layout("Summarizer") {
		<div class="text-center mb-8">
			<h1 class="text-4xl font-bold text-gray-100 mb-2">YouTube Video Summarizer</h1>
			<p class="text-gray-400">Get AI-powered summaries of YouTube videos instantly</p>
		</div>
		<div class="bg-gray-800 border border-gray-700 rounded-lg shadow-xl p-6 mb-8">
			<h2 class="text-2xl font-semibold text-gray-100 mb-4">Upload and Summarize</h2>
			<form hx-post="/summarize" hx-target="#result" hx-indicator="#loading" class="space-y-4">
				<div>
					<label for="url" class="block text-sm font-medium text-gray-300 mb-2">Enter YouTube URL to summarize:</label>
					<input 
						id="url" 
						name="url" 
						placeholder="https://www.youtube.com/watch?v=..." 
						class="w-full px-3 py-2 border border-gray-600 bg-gray-700 text-gray-100 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 placeholder-gray-400"
					/>
				</div>
				<div>
					<label for="model" class="block text-sm font-medium text-gray-300 mb-2">Select AI Model:</label>
					<select 
						id="model" 
						name="model" 
						class="w-full px-3 py-2 border border-gray-600 bg-gray-700 text-gray-100 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
					>
						<option value="gemini-2.5-pro-preview-05-06">Gemini 2.5 Pro Preview (Default)</option>
						<option value="gemini-2.5-flash-preview-05-20">Gemini 2.5 Flash Preview</option>
						<option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
					</select>
				</div>
				<div class="flex items-center space-x-4">
					<button 
						type="submit" 
						id="submit-btn"
						class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
					>
						Summarize
					</button>
					<div id="loading" class="htmx-indicator text-blue-400 font-medium">
						<div class="flex items-center space-x-2">
							<div class="animate-spin h-4 w-4 border-2 border-blue-400 border-t-transparent rounded-full"></div>
							<span>Processing...</span>
						</div>
					</div>
				</div>
			</form>
		</div>
		<div id="result"></div>
	}
}

templ SummaryResult(summary string) {
	<div class="bg-gray-800 border border-gray-700 rounded-lg shadow-xl mb-8">
		<!-- Reader Controls -->
		<div class="reader-controls rounded-t-lg p-4 border-b border-gray-700">
			<div class="flex items-center justify-between mb-3">
				<div class="flex items-center space-x-4">
					<h3 class="text-xl font-semibold text-gray-100">Summary Reader</h3>
					<div class="flex items-center space-x-2">
						<button 
							id="bionic-toggle"
							onclick="toggleBionic()"
							class="bg-blue-600 hover:bg-blue-700 text-white text-sm px-3 py-1 rounded transition-colors duration-200"
						>
							Enable Bionic Reading
						</button>
						<button 
							onclick="adjustFontSize(1)"
							class="bg-gray-600 hover:bg-gray-700 text-white text-sm px-2 py-1 rounded"
						>
							A+
						</button>
						<button 
							onclick="adjustFontSize(-1)"
							class="bg-gray-600 hover:bg-gray-700 text-white text-sm px-2 py-1 rounded"
						>
							A-
						</button>
					</div>
				</div>
				<button 
					hx-get="/" 
					hx-target="body" 
					hx-push-url="true"
					class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2"
				>
					New Summary
				</button>
			</div>
			
			<!-- Reading Progress -->
			<div class="space-y-2">
				<div class="flex items-center justify-between reading-stats">
					<div class="flex items-center space-x-4">
						<span id="word-count">0 words</span>
						<span id="reading-time">~0 min read</span>
						<span id="progress-percent">0% complete</span>
					</div>
					<span id="time-remaining">~0 min remaining</span>
				</div>
				<div class="progress-bar">
					<div id="progress-fill" class="progress-fill" style="width: 0%"></div>
				</div>
			</div>
		</div>
		
		<!-- Reader Content -->
		<div class="p-8">
			<div id="reader-content" class="reader-content">
				@templ.Raw(summary)
			</div>
		</div>
	</div>
	
	<script>
		(function() {
			console.log('Initializing reading progress for new summary...');
			
			let totalWords = 0;
			let readingSpeed = 200; // words per minute
			
			// Initialize reading progress
			function initializeReadingProgress() {
				const content = document.getElementById('reader-content');
				if (!content) {
					console.log('Reader content not found');
					return;
				}
				
				// Calculate word count
				const text = content.textContent || content.innerText;
				const words = text.trim().split(/\s+/).filter(word => word.length > 0);
				totalWords = words.length;
				
				console.log('Reading progress initialized:', {
					contentFound: !!content,
					textLength: text.length,
					totalWords: totalWords
				});
				
				if (totalWords === 0) {
					console.log('No words found in content');
					return;
				}
				
				// Calculate reading time
				const totalMinutes = Math.max(1, Math.ceil(totalWords / readingSpeed));
				
				// Update UI elements
				const wordCountEl = document.getElementById('word-count');
				const readingTimeEl = document.getElementById('reading-time');
				const timeRemainingEl = document.getElementById('time-remaining');
				
				if (wordCountEl) wordCountEl.textContent = `${totalWords.toLocaleString()} words`;
				if (readingTimeEl) readingTimeEl.textContent = `~${totalMinutes} min read`;
				if (timeRemainingEl) timeRemainingEl.textContent = `~${totalMinutes} min remaining`;
				
				// Set initial font size
				content.style.fontSize = (window.currentFontSize || 18) + 'px';
				
				// Setup scroll tracking
				setupScrollTracking();
			}
			
			function setupScrollTracking() {
				const content = document.getElementById('reader-content');
				const progressFill = document.getElementById('progress-fill');
				const progressPercent = document.getElementById('progress-percent');
				const timeRemaining = document.getElementById('time-remaining');
				
				if (!content || !progressFill) {
					console.log('Missing elements for scroll tracking');
					return;
				}
				
				function updateProgress() {
					const windowHeight = window.innerHeight;
					const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
					
					// Get content position relative to document
					const contentRect = content.getBoundingClientRect();
					const contentTop = scrollTop + contentRect.top;
					const contentHeight = content.offsetHeight;
					const contentBottom = contentTop + contentHeight;
					
					// Calculate progress based on how much content has been scrolled past
					let progress = 0;
					
					if (scrollTop + windowHeight >= contentTop) {
						// User has reached the content area
						const viewportBottom = scrollTop + windowHeight;
						
						if (viewportBottom >= contentBottom) {
							// User has scrolled past the entire content
							progress = 100;
						} else {
							// Calculate partial progress
							const visibleContentHeight = Math.max(0, viewportBottom - contentTop);
							progress = Math.min(100, (visibleContentHeight / contentHeight) * 100);
						}
					}
					
					// Update UI elements
					progressFill.style.width = `${progress}%`;
					if (progressPercent) progressPercent.textContent = `${Math.round(progress)}% complete`;
					
					// Update time remaining
					const remainingWords = Math.ceil(totalWords * (100 - progress) / 100);
					const remainingMinutes = Math.max(0, Math.ceil(remainingWords / readingSpeed));
					if (timeRemaining) {
						timeRemaining.textContent = remainingMinutes > 0 ? 
							`~${remainingMinutes} min remaining` : 'Complete!';
					}
				}
				
				// Throttled scroll listener
				let ticking = false;
				function onScroll() {
					if (!ticking) {
						requestAnimationFrame(() => {
							updateProgress();
							ticking = false;
						});
						ticking = true;
					}
				}
				
				window.addEventListener('scroll', onScroll);
				window.addEventListener('resize', updateProgress);
				updateProgress(); // Initial calculation
				
				console.log('Scroll tracking setup complete');
			}
			
			// Initialize immediately since content is already loaded
			initializeReadingProgress();
		})();
	</script>
	
	<script>
		// Global reader functions (available to all readers)
		let currentFontSize = 18;
		
		function toggleBionic() {
			const content = document.getElementById('reader-content');
			const button = document.getElementById('bionic-toggle');
			let bionicEnabled = button.textContent.includes('Disable');
			
			if (!bionicEnabled) {
				applyBionicText(content);
				button.textContent = 'Disable Bionic Reading';
				button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
				button.classList.add('bg-green-600', 'hover:bg-green-700');
			} else {
				removeBionicText(content);
				button.textContent = 'Enable Bionic Reading';
				button.classList.remove('bg-green-600', 'hover:bg-green-700');
				button.classList.add('bg-blue-600', 'hover:bg-blue-700');
			}
		}
		
		function applyBionicText(element) {
			const walker = document.createTreeWalker(
				element,
				NodeFilter.SHOW_TEXT,
				null,
				false
			);
			
			const textNodes = [];
			let node;
			while (node = walker.nextNode()) {
				if (node.parentElement.tagName !== 'CODE' && node.parentElement.tagName !== 'PRE') {
					textNodes.push(node);
				}
			}
			
			textNodes.forEach(textNode => {
				const text = textNode.textContent;
				const words = text.split(/(\s+)/);
				const fragment = document.createDocumentFragment();
				
				words.forEach(word => {
					if (word.trim()) {
						const span = document.createElement('span');
						span.className = 'bionic-word';
						
						const cleanWord = word.replace(/[^\w]/g, '');
						if (cleanWord.length > 1) {
							const bionicLength = Math.max(1, Math.ceil(cleanWord.length * 0.5));
							const bionicPart = word.substring(0, bionicLength);
							const normalPart = word.substring(bionicLength);
							
							span.innerHTML = `<span class="bionic">${bionicPart}</span><span class="non-bionic">${normalPart}</span>`;
						} else {
							span.innerHTML = `<span class="non-bionic">${word}</span>`;
						}
						fragment.appendChild(span);
					} else {
						fragment.appendChild(document.createTextNode(word));
					}
				});
				
				textNode.parentNode.replaceChild(fragment, textNode);
			});
		}
		
		function removeBionicText(element) {
			const bionicWords = element.querySelectorAll('.bionic-word');
			bionicWords.forEach(word => {
				const text = word.textContent;
				word.parentNode.replaceChild(document.createTextNode(text), word);
			});
		}
		
		function adjustFontSize(delta) {
			currentFontSize += delta * 2;
			currentFontSize = Math.max(12, Math.min(28, currentFontSize));
			const content = document.getElementById('reader-content');
			if (content) {
				content.style.fontSize = currentFontSize + 'px';
			}
		}
	</script>
}
